MANNING 2007 - EJB IN ACTION

---------------- CAPITOLO 1 ----------------
Tre tipi di EJB COmponents: session bean, message driven bean, entities. I primi 2 per la logica di business e il terzo per la persistenza.
Il framework EJB contiene una serie di servizi gia implementati che permettono allo sviluppatore di conentrarsi sullo sviluppo della logica di business.
Questi servixi sono avviabili sugli EJB COmponent quando loro sono deployati nel lodo EJB container.
Grazie a Java 5 dove è possibile utilizzare le annotazioni e la dependency injection il container può offirre questi servizi:
- transazioni
- sicurezza
- persistenza
- remotezza
- interceptors
- timers
- state management
- messaggistica

Tramite le annotazioni(metadata) lo sviluppatore dice cosa deve essere fatto e il sistemma aggiunge il codice per farlo.
Una annotazione trasforma un semplice POJO in un EJB.

Siccome i programmi hanno più o meno tutti la stessa logica cioè restituire ed elaborare dati salvati ci si affida a dei pattern utilizzando una architettura a livelli.
Ogni livello fornisce informazioni al livello sottostante.
EJB permette di cotruire applicazioni utilizzando 2 diverse architetture a livelli:
- TRADITIONAL FOUR TIER LAYERED ARCHITECTURE
	a) presentation layer(GUI) per l'imput dell'utente
	b) business logic layer è il cuore dell'applicazione e contiene workflow e processi logici
	c) persistence layer è una astrazione di alto livello Object Oriented del dabase layer
	d) database layer consiste nel database relazionale(RDBMS) come Oracle, DB2, Sql Server...
- DOMAIN DRIVEN DESIGN(DDD)
	Concentrarsi sul dominio e rendere gli oggetti entity capaci di avere comportamenti e di impiegare le caratteristiche dell'OO come l'ereditarietà e il poliformismo.

EJB Component è definito 'bean'
Il persistence provider agisce, come il container per i session e message driven bean, ma per le entity.
Il persistence provider è inserito all'interno del container e si astrae dietro le Java Persistence API (JPA)(FIGURA PAG 16)


SESSION BEAN
Viene invocvato da un client per l'esecuzione di specifiche operazioni di business.
Il nome session implica che un'istanza del bean è avviabile per la durata di una unità di lavoro e non sopravvive e crash o spegnimento del server.
Due tipi:
- Stateful:
	salva automaticamente lo stato del bean tra le invocazioni dello stesso client(Es. il carrello di Amazon)
- Stateless:
	Non mantiene nessuno stato tra una invocazione e l'altra dal aprte di un client(Es. carica carta di credito o controllo storico carta=

Un session bean può essere incovato Localmente o remotamente tramite Java RMI.
Uno stateless session bean può essere esposto come WEB SERVICE


MESSAGE-DRIVEN BEAN
Processa la logica di business.
I clients non invocano il MDB direttamente, ma il MDB viene triggerato dai messaggi inviati al server, che ha abilitato la messaggistica asincrona tra i componenti del sistema.


ENTITIES AND JPA
La persistenza è l'abilità di avere i dati contenuti in oggetti java automaticamente salvati su database relazionali(ORM - object relational mapping/ Es. Hibernate)
In EJB 3 la persistenza è gestita dalle JPA che a sua volta è semplificata tramite gli ORM.
I JPA definiscono uno standard per:
- creazione di mertadata per la configurazione ORM per mappare le entities alle tabelle relazionali
- l'entity manager api - un api standard per eseguire operazioni di persistenza CRUD sulle entity(create, read, update and delete)/
- il Java Persistence Query Language(JPQL), per cercare e trovare dati applicativi stored(salvati sul db)

Si possono aggiungere diversi prodotti ORM sulle JPA come Jboss Hibernate, Oracle TopLink o BEA Kodo utilizzandoli come persistence provider della propria applicazione.

ENTITIES
Sono la rappresentazione OO delle entità presenti sul database e includono capacita ri relazione, ereditarietà e plomorfismo
Contengono metadata per mappare i campi del database con i campi dell'oggetto

ENTITY MANAGER
L'interfaccia JPA EntityManager gestisce le entities in termini di provvedere fisicamente ai servizi di persistenza.
Esso conosce come salvare i dati delle entity nel database, upload e delete e select.
JPA ha la capacità di gestire il cliclo di vita, le perdormance, il caching e il transaction management.
	
JPQL
specifica SQL-LIKE linguaggio delle query

1.3 Pag 19
FIGURA 1.7 Raggruppamento Java EE Container[ web Container, Ejb contaienr, persistence provider]

Glassfish, Jboss hanno JavaEEContainer
Tomcat ha solo {web contaqiner e persistence provider(hibernate)}


SERVIZI GESTITI DALL'EJB CONTAINER E DAL PERSISTENCE PROVIDER
(- Service, = Applies To, >Means)

- Integration
= Session bean and MDBs
> aiuta ad incollare insieme i componenti tramite semplici configurazioni invece di codice.
	Utili sono la dependency injection DI e le lookup

- Pooling
= Stateless session beans, MDBs
> per ogni EJB component l'EJB platform crea un pool di istanze dei suddetti componenti che vengono condivisi tra i clients.
	Quando un client smette di usare una di queste istanze, ques'tultima torna nel pool per essere riutilizzata

- Thread-safety
= Session Beans e MDBs
> Ejb rende tutti i componenti thread safe e performanti in modo invisibile. 
	In questo modo lo sviluppatore può scrivere componenti server come una applicazione single-thread desktop senza preoccuparsi di questa complessità.
	
- State Management
= Stateful session beans
> Il container gestisce in maniera trasparente lo stato delle singole istanze di queste componenti

- Messaging
= MDBs
> permette di scrivere messaggi senza avere idea della logica di comunicazione di tali messaggi.

- Transactions
= Session Beans and MDB
> Configurabile tramite configurazione, no codice. Si può definire un metodo transazionale, se finisce correttamente committa altrimenti fa rollback.

- Security
= Session Beans
> Ejb supporta l'integrazione con le API di Java Authentication and Authorization Service (JAAS). Configurazione no codice.

- Interceprots
= Session beans e MDBs
> permette di separare il logging, l'auditing in maniera configurabile.

- Remote access
= Session beans
> è possibile rendere remoti i componenti senza scrivere codice aggiuntivo ma come se fosse codice locale tramite DI

- Web service
= Stateless session bean
> Ejb 3 può girare di componenti di business in dei web services in maniera trasparente e con piccole modifiche al codice

- persistence
= entities
> é il punto di maggior successo di EJB 3, fornisce servizi basati su standard ed è conigurabile al 100 %

- caching and performance
= entities
> JPA fornisce in maniera trasparente un numero di servizi orinentati al caching dei dati, all'ottimizzazione delle performance e dell'applicazione.

DTO: Data transfer Object creati per la comunicazione dei session ben con il livello di prsentazione poichè non si deve collegare un oggetto entity ad una interfaccia poichè riverserebbe direttamente le modifiche sul db.


---------------- CAPITOLO 2 ----------------
Possono essere utilizzate le annotazioni oppure i deployment descriptor.
Di solito si utilizzano entrambi ma i deployment per specificare la configurazione di un ambiente in particolare e le annotazioni per tutto il resto.
Le annorazioni sono in javax.annotation.*; specificate da Java 5.

Application Client Container(ACC)
è un mini Java EE container che può essere lanciato da linea di comando.
Si può pensare ad una JVM con qualcosa di Java EE iniettato.
Riconosce molte annotazioni come @EJB utile ad iniettare delle classi presenti sul server e quindi remote tramite la DI.
la comunicazione avviene tramite RMI e il container provvede all'autenticazione, autorizzazione, ecc.
Tecnologia utile per i test di unità(JUnit)
Ogni classe con un main gira all'interno dell'ACC in un application client inpacchettato in un file JAR che deve contenere la MainClass anche nel manifest.
Opzionalmente il JAR deve contenere un deployment descriptor(application-client.xml) e jndi.properties che contiene le configurazione dell'ambiene a cui connettersi per un Ejb container remoto.
Esempio di lancio su Glassfish : appclient -client chapter2-client.jar

MESSAGE DRIVEN BEAN(MDB)
@MessageDriven annotazione da mettere sulla classe MDB che contiene la sua configurazione:
	activationConfig: parametro configurazione che contiene le @ActivationConfigProperty
	@ActivationConfigProperty: annotazione che contiene propertyName e properyValue che sono i nome e il path della queue di messaggi salvata
Ogni classe MDB deve estendere la classe MessageListener per poter gestire i messaggi con il metodo onMessage()

Es. intestazione MDB:
	@MessageDriven(activationConfig = {
			@ActivationConfigProperty(propertyName = "destination", propertyValue = "jms/OrderBillingQueue"), //Coda personalizzata
			@ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue") }) //Tipo di coda default, può essere anche Topic
	public class OrderBillingMDB implements MessageListener {
		void onMessage(Message message){
			ObjectMessage objectMessage = (ObjectMessage) message;
			ExampleObject e = (ExampleObject) objectMessage
			...
		}
	}

Un bean che chiama un MDB deve definire un connection Factory e una coda a cui agganciarsi:
Es. Oggetti per accesso al MDB
	@Resource(name = "jms/QueueConnectionFactory", mappedName = "ConnectionFactory")
	private QueueConnectionFactory connectionFactory;

	@Resource(name = "jms/OrderBillingQueue", mappedName = "jms/OrderBillingQueue")
	private Queue billingQueue;

Es. Modalità accesso MDBs
	Connection connection = connectionFactory.createConnection();
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	MessageProducer producer = session.createProducer(billingQueue);
	ObjectMessage message = session.createObjectMessage();
	message.setObject(....es. new Object());
	producer.send(message);
	producer.close();
	session.close();
	connection.close();

PERSISTENZA:
Es. istanziazione di un Entity Manager
	@PersistenceContext(unitName = "actionBazaar") //Inietta l'istanza dell'EntityManager
	private EntityManager em;
Es. Crud di un oggetto @Entity
		em.persist(<Object @Entity>);// inserisce l'id nell'oggetto
		em.update(<Object @Entity>);
		em.delete(<Object @Entity>);
Es. generazione di una classe entity
	@Entity //Trasformazione de POJO in entity
	@Table(name="BIDS") //Riferimento alla tabella
	public class Bid implements Serializable { //La classe deve essere serializzabile
		private Long bidID;
		private Long itemID;
		private Long bidderID;
		private Double bidAmount;
		private Date bidDate;
		
		@Id //Costante che definisce l'id della tabella, la chiave primaria
		@GeneratedValue(strategy=GenerationType.AUTO) //tipo di generazione dell'id, qusta modalità indica che ad ogni salvataggio di una nuova istanza la chiave viene generata automaticamente
		@Column(name="BID_ID") //colonna di riferimento
		public Long getBidID() {
			return bidID;
		}
		public void setBidID(Long bidID) {
			this.bidID = bidID;
		}
		
		@Column(name="ITEM_ID") //Colonna di riferimento
		public Long getItemID() {
			return itemID;
		}
		public void setItemID(Long itemID) {
			this.itemID = itemID;
		}
		....
	}


---------------- CAPITOLO 3 ----------------
Un session bean deve:
- avere almento un business interface(@Local o @Remote)
- essere una classe concreta(no abstract method) e non classe final poichè il container deve porterla manipolare
- costruttore senza argomenti(utile al container poichè il client non istanzia direttamente la classe ma usa DI)
- può essere una sotto classe di un altro session bean(? od i una clase POJO)
- i metodi non devono iniziare con 'ejb' poichè interferiscono con il funzionamento dell'infrastruttura
- non si possono definire metodi final o static
- sia gli argomenti che i valori di ritorno devono implementare l'interfaccia Serializable

Sui session bean si possono applicare le annotazioni come interceptor @PostCreate, @PreDestroy, @PostActivate, e @PrePassivate(disattivazione temporanea di un bean non utilizzato, solo per gli stateful session bean)

@Stateless(name='') // attributo utilizzato per mappare il bean nel JNDI, se omesso viene inserito il nome della classe

Un session bean può essere invocato in tre modi: localmente nella JVM (@Local), in maniera remota attraverso RMI(@Remote) e in maniera remota come web service(@WebService).

E' possibile inserire tutte e tre le interfacce per un session bean senza scriverle direttamente uytilizzando il seguente codice:
Es.:
	@Remote(ExampleInterface.class)
	@Stateless
	public class ExampleBean{
	...
	}
	
Negli stateful session bean tutte le vatiabili per soddisfare i requisiti della passivizzazione dell'entity devono essere serializzabili
Al contrario degli stateless non possono essere istanziati e messi in un pool a priori
Esiste l'anotazione @Remove per rimuovere tutti gli oggetti istanziatiche altrimenti rimarrebbero in memoria.
La passivasione salva il bean sul disco e non in memoria, dopo un certo periodo di inutilizzo lo rimuove del tutto.

I stateful session bean possono creare criticità nel sistema, come spreco di memoria a causa di oggetti non eliminati e quindi un calo delle prestazioni.
Alternative ai stateful session bean(di difficile manutenzione i primi 2):
- stateless bean + persistence: per ogni richiesta i dati vengono salvati direttamente sul db.
- aggiungere meccanismi lato client che mantengano lo stato
-* mantenere la sessione in un web container nel caso di una web application. Sebbene l'http è un protocollo stateless le Java servlet Api permettono di mantenere lo stato tramite l'HttpSession.

Best Practice
- scegliere bene se usare stateful o oggetti httpsession e solo se neccessario
- usare interfacce remote solo se necessario
- non iniettare stateful session bean in stateless session bean o in servlet
- separare i concetti incrociati come logging e auditing utilizzando gli interceptor
- scegliere gli oggetti più piccoli o primitivi da salvare come variabili dei stateful
- non dimenticare di creare @Remove per gli stateful
- gestire la passivazione e la configurazione dei timeout


---------------- CAPITOLO 4 ----------------
Una classe MDB deve:
- implementare direttamente o indirettamente(lookup o Di) l'interfaccia messageListener
- deve esdsere una classe concreta e non final o abstract
- non può essere sottoclasse di un altro MDB
- deve essere public
- deve avere un costruttore senza argomenti(se nn c'è viene creato automaticamente)
- esiste il preDestroy

Message selector: utile a filtrare i messaggi, sono criteri applicati all'header o alle proprietà del messaggio.
Es. Creazione del consumer
	MessageConsumer consumer = session.createCostumer(destination, "Fragile IS TRUE");
Es2. Definizione del MDB 
	@ActivationConfigProperty(
		propertyName="messageSelector",
		propertyValue="Fragile IS TRUE")

L'MDB crea un pool di istanze che al momento debito ne tira fuori una per gestire un messaggio e poi appena finito la riporta nel pool.ù

Un MDB può mandare a sua volta messaggi tramite Di in un altra MDB utilizzata ad esempio per tracciare gli errori.
L'apertura e la chiusura della connesione con la coda può essere gestita anche da interceptor @postConstruct e @PreDestroy come per le connesioni al DB.

---------------- CAPITOLO 5 ----------------
Per ogni istanza di un bean, il container in automatico genera un procy chiamato EJB Object. Esso ha accesso a tutte le funzionalità del container(jndi, registry, security,...).
Tramite gli EJB si può accedere al EJBContext come il SessionContext e il MessageDrivenContext utilizzando l'annotazione @Resource, il context è utile per avere informazioni a runtime e servizi
@Resource di solito è usato quando deve essere esplicitato il nome(JDBC, Context, MDB...)
(differenze di utilizzo di @resource sul metodo, variabile o classe)
Tramite @Resource è possibile dare dei parametri a seconda della configurazione dell'ambiente
Es. 
	@Resource(name="valueExample")
	private boolena valueExample
Es.
	<env-entry>
		<env-entry-name>censorship</env-entry-name>
		<env-entry-type>java.lang.Boolean</env-entry-type>
		<env-entry-value>true</env-entry-value>
	</env-entry>

Tramite lookup a differenza della DI è che lke dipendenze vengono specificate programatticamente e che quindi il carico di lavoro
per importare le classi utili avviene a deployment time e non a runtime come per la DI

AOP: Aspect Oriented Programming
Interceptor: 
- default interceptor: definito per tutte le classi presenti nel modulo EJB
- class interceptor 
- method interceptor.
Se sono definiti più di un su un unica classe vengono chaiamati nell'ordine elencato precedentemente.
@AroundInvoke: per definire un metodo in una classe interceptor
Es. 
	@AroundInvoke
	public Object giveDiscount(InvocationContext context) throws Exception {
		System.out.println("*** DiscountVerifier Interceptor" + " invoked for " + context.getMethod().getName() + " ***");
		if (context.getMethod().getName().equals("chargePostingFee") && (((String)(context.getContextData().get("MemberStatus"))).equals("Gold"))) {
			Object[] parameters = context.getParameters();
			parameters[2] = new Double ((Double) parameters[2] * 0.99);
			System.out.println ("*** DiscountVerifier Reducing Price by 1 percent ***");
			context.setParameters(parameters);
		}
		return context.proceed();
	}
Per utilizzarlo su una classe o su un metodo: @Interceptors({ActionBazaarResourceLogger.class})
Definizione di uno di default:
	<assembly-descriptor>
		<interceptor-binding>
		<ejb-name>*</ejb-name>
		<interceptor-class>
			actionbazaar.buslogic.ActionBazaarLogger
		</interceptor-class>
		</interceptor-binding>
	</assembly-descriptor>
Esistono funzionalità per rimuovere l'interceptor @ExcludeDefaultInterceptors e @ExcludeClassInterceptors.


@Timer utile per schedulare il lancio di alcuni metodi
ES.
	public class PlaceBidBean implements PlaceBid {
		...
		@Resource TimerService timerService;
		...
		public void addBid(Bid bid) {
			... Code to add the bid ...
			timerService.createTimer(15*60*1000, 15*60*1000, bid);  //creato il timer
			...
		}
		...
		@Timeout     //metodo di timeout
		public void monitorBid(Timer timer) { //Nella  firma c'è la classe timer
			Bid bid = (Bid) timer.getInfo();
			... Code to monitor the bid ...
		}
	}
Si può accedere al timer service anche tramite SessionContext
I timer Ejb sopravvivono al restart dell'EJB Container ma non sono buone per applicazioni realtime


---------------- CAPITOLO 6 ----------------
Context managed transaction: CMT
Transazionale: ACID(Atomicity, Consistency, isolation, Durability)
Lock di basso livello sul database per i dati modificati dalla transazione, nessun'altro li può modificare fino a quando non termina la transazione.
Es.
	@Stateless
	@TransactionManagement(TransactionManagementType.CONTAINER) //Utilizzato CMT Container-menaged transaction
	public class OrderManagerBean {
		@Resource    															//Inject del contesto utile per il rollback
		private SessionContext context;
		...
		@TransactionAttribute(TransactionAttributeType.REQUIRED)  				//Definito un attributo di transaction per metodo
		public void placeSnagItOrder(Item item, Customer customer){				//attributi: REQUIRED, REQUIRES_NEW, SUPPORTS, MANDATORY, NOT_SUPPORTED, NEVER
			try {
				if (!bidsExisting(item)){
					validateCredit(customer);
					chargeCustomer(customer, item);
					removeItemFromBidding(item);
				}
			} catch (CreditValidationException cve) { 							//Roolback in caso di eccezione
				context.setRollbackOnly();										// il contesto viene marcato "da rollbackare" e fatto successivamente(solo per REQUIRED, REQUIRES_NEW, MANDATORY altrimenti va in eccezione)
			} catch (CreditProcessingException cpe){
				context.setRollbackOnly();
			} catch (DatabaseException de) {
			}
		}
	}
MDB supporta solo: REQUIRED e NOT_SUPPORTED
@ApplicationException: utilizzato per gestire i rollback sulle eccezioni
Es. Rimozione del try catch ed eccezioni personalizzate
	public void placeSnagItOrder(Item item, Customer customer)throws CreditValidationException,	CreditProcessingException, DatabaseException {
		if (!bidsExisting(item)){
			validateCredit(customer);
			chargeCustomer(customer, item);
			removeItemFromBidding(item);
		}
	}
	...
	@ApplicationException(rollback=true)
	public class CreditValidationException extends Exception {
	...
	@ApplicationException(rollback=true)
	public class CreditProcessingException extends Exception {
	...
	@ApplicationException(rollback=false)
	public class DatabaseException extends	RuntimeException {
	...
 
Bean managed transaction: BMT (puo dettagliare le scelte sulle transazioni)
Es.
	@Stateless
	@TransactionManagement(TransactionManagementType.BEAN) //Use BMT
	public class OrderManagerBean {
		@Resource
		private UserTransaction userTransaction;  //Inject User transaction
		
		public void placeSnagItOrder(Item item, Customer customer){
			try {
				userTransaction.begin();   //Start transaction
				if (!bidsExisting(item)){
					validateCredit(customer);
					chargeCustomer(customer, item);
					removeItemFromBidding(item);
				}
				userTransaction.commit();   //Commit transaction
				
			} catch (CreditValidationException cve) { //Rolls back sulle eccezioni
				userTransaction.rollback();
			} catch (CreditProcessingException cpe){
				userTransaction.rollback();
			} catch (DatabaseException de) {
				userTransaction.rollback();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	
Continua da pagina 197
 
 
 
 
 
 