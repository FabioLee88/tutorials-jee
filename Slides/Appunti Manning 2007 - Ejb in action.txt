MANNING 2007 - EJB IN ACTION

---------------- CAPITOLO 1 ----------------
Tre tipi di EJB COmponents: session bean, message driven bean, entities. I primi 2 per la logica di business e il terzo per la persistenza.
Il framework EJB contiene una serie di servizi gia implementati che permettono allo sviluppatore di conentrarsi sullo sviluppo della logica di business.
Questi servixi sono avviabili sugli EJB COmponent quando loro sono deployati nel lodo EJB container.
Grazie a Java 5 dove è possibile utilizzare le annotazioni e la dependency injection il container può offirre questi servizi:
- transazioni
- sicurezza
- persistenza
- remotezza
- interceptors
- timers
- state management
- messaggistica

Tramite le annotazioni(metadata) lo sviluppatore dice cosa deve essere fatto e il sistemma aggiunge il codice per farlo.
Una annotazione trasforma un semplice POJO in un EJB.

Siccome i programmi hanno più o meno tutti la stessa logica cioè restituire ed elaborare dati salvati ci si affida a dei pattern utilizzando una architettura a livelli.
Ogni livello fornisce informazioni al livello sottostante.
EJB permette di cotruire applicazioni utilizzando 2 diverse architetture a livelli:
- TRADITIONAL FOUR TIER LAYERED ARCHITECTURE
	a) presentation layer(GUI) per l'imput dell'utente
	b) business logic layer è il cuore dell'applicazione e contiene workflow e processi logici
	c) persistence layer è una astrazione di alto livello Object Oriented del dabase layer
	d) database layer consiste nel database relazionale(RDBMS) come Oracle, DB2, Sql Server...
- DOMAIN DRIVEN DESIGN(DDD)
	Concentrarsi sul dominio e rendere gli oggetti entity capaci di avere comportamenti e di impiegare le caratteristiche dell'OO come l'ereditarietà e il poliformismo.

EJB Component è definito 'bean'
Il persistence provider agisce, come il container per i session e message driven bean, ma per le entity.
Il persistence provider è inserito all'interno del container e si astrae dietro le Java Persistence API (JPA)(FIGURA PAG 16)


SESSION BEAN
Viene invocvato da un client per l'esecuzione di specifiche operazioni di business.
Il nome session implica che un'istanza del bean è avviabile per la durata di una unità di lavoro e non sopravvive e crash o spegnimento del server.
Due tipi:
- Stateful:
	salva automaticamente lo stato del bean tra le invocazioni dello stesso client(Es. il carrello di Amazon)
- Stateless:
	Non mantiene nessuno stato tra una invocazione e l'altra dal aprte di un client(Es. carica carta di credito o controllo storico carta=

Un session bean può essere incovato Localmente o remotamente tramite Java RMI.
Uno stateless session bean può essere esposto come WEB SERVICE


MESSAGE-DRIVEN BEAN
Processa la logica di business.
I clients non invocano il MDB direttamente, ma il MDB viene triggerato dai messaggi inviati al server, che ha abilitato la messaggistica asincrona tra i componenti del sistema.


ENTITIES AND JPA
La persistenza è l'abilità di avere i dati contenuti in oggetti java automaticamente salvati su database relazionali(ORM - object relational mapping/ Es. Hibernate)
In EJB 3 la persistenza è gestita dalle JPA che a sua volta è semplificata tramite gli ORM.
I JPA definiscono uno standard per:
- creazione di mertadata per la configurazione ORM per mappare le entities alle tabelle relazionali
- l'entity manager api - un api standard per eseguire operazioni di persistenza CRUD sulle entity(create, read, update and delete)/
- il Java Persistence Query Language(JPQL), per cercare e trovare dati applicativi stored(salvati sul db)

Si possono aggiungere diversi prodotti ORM sulle JPA come Jboss Hibernate, Oracle TopLink o BEA Kodo utilizzandoli come persistence provider della propria applicazione.

ENTITIES
Sono la rappresentazione OO delle entità presenti sul database e includono capacita ri relazione, ereditarietà e plomorfismo
Contengono metadata per mappare i campi del database con i campi dell'oggetto

ENTITY MANAGER
L'interfaccia JPA EntityManager gestisce le entities in termini di provvedere fisicamente ai servizi di persistenza.
Esso conosce come salvare i dati delle entity nel database, upload e delete e select.
JPA ha la capacità di gestire il cliclo di vita, le perdormance, il caching e il transaction management.
	
JPQL
specifica SQL-LIKE linguaggio delle query

1.3 Pag 19
FIGURA 1.7 Raggruppamento Java EE Container[ web Container, Ejb contaienr, persistence provider]

Glassfish, Jboss hanno JavaEEContainer
Tomcat ha solo {web contaqiner e persistence provider(hibernate)}


SERVIZI GESTITI DALL'EJB CONTAINER E DAL PERSISTENCE PROVIDER
(- Service, = Applies To, >Means)

- Integration
= Session bean and MDBs
> aiuta ad incollare insieme i componenti tramite semplici configurazioni invece di codice.
	Utili sono la dependency injection DI e le lookup

- Pooling
= Stateless session beans, MDBs
> per ogni EJB component l'EJB platform crea un pool di istanze dei suddetti componenti che vengono condivisi tra i clients.
	Quando un client smette di usare una di queste istanze, ques'tultima torna nel pool per essere riutilizzata

- Thread-safety
= Session Beans e MDBs
> Ejb rende tutti i componenti thread safe e performanti in modo invisibile. 
	In questo modo lo sviluppatore può scrivere componenti server come una applicazione single-thread desktop senza preoccuparsi di questa complessità.
	
- State Management
= Stateful session beans
> Il container gestisce in maniera trasparente lo stato delle singole istanze di queste componenti

- Messaging
= MDBs
> permette di scrivere messaggi senza avere idea della logica di comunicazione di tali messaggi.

- Transactions
= Session Beans and MDB
> Configurabile tramite configurazione, no codice. Si può definire un metodo transazionale, se finisce correttamente committa altrimenti fa rollback.

- Security
= Session Beans
> Ejb supporta l'integrazione con le API di Java Authentication and Authorization Service (JAAS). Configurazione no codice.

- Interceprots
= Session beans e MDBs
> permette di separare il logging, l'auditing in maniera configurabile.

- Remote access
= Session beans
> è possibile rendere remoti i componenti senza scrivere codice aggiuntivo ma come se fosse codice locale tramite DI

- Web service
= Stateless session bean
> Ejb 3 può girare di componenti di business in dei web services in maniera trasparente e con piccole modifiche al codice

- persistence
= entities
> é il punto di maggior successo di EJB 3, fornisce servizi basati su standard ed è conigurabile al 100 %

- caching and performance
= entities
> JPA fornisce in maniera trasparente un numero di servizi orinentati al caching dei dati, all'ottimizzazione delle performance e dell'applicazione.

DTO: Data transfer Object creati per la comunicazione dei session ben con il livello di prsentazione poichè non si deve collegare un oggetto entity ad una interfaccia poichè riverserebbe direttamente le modifiche sul db.


---------------- CAPITOLO 2 ----------------
Possono essere utilizzate le annotazioni oppure i deployment descriptor.
Di solito si utilizzano entrambi ma i deployment per specificare la configurazione di un ambiente in particolare e le annotazioni per tutto il resto.
Le annorazioni sono in javax.annotation.*; specificate da Java 5.

Application Client Container(ACC)
è un mini Java EE container che può essere lanciato da linea di comando.
Si può pensare ad una JVM con qualcosa di Java EE iniettato.
Riconosce molte annotazioni come @EJB utile ad iniettare delle classi presenti sul server e quindi remote tramite la DI.
la comunicazione avviene tramite RMI e il container provvede all'autenticazione, autorizzazione, ecc.
Tecnologia utile per i test di unità(JUnit)
Ogni classe con un main gira all'interno dell'ACC in un application client inpacchettato in un file JAR che deve contenere la MainClass anche nel manifest.
Opzionalmente il JAR deve contenere un deployment descriptor(application-client.xml) e jndi.properties che contiene le configurazione dell'ambiene a cui connettersi per un Ejb container remoto.
Esempio di lancio su Glassfish : appclient -client chapter2-client.jar

MESSAGE DRIVEN BEAN(MDB)
@MessageDriven annotazione da mettere sulla classe MDB che contiene la sua configurazione:
	activationConfig: parametro configurazione che contiene le @ActivationConfigProperty
	@ActivationConfigProperty: annotazione che contiene propertyName e properyValue che sono i nome e il path della queue di messaggi salvata
Ogni classe MDB deve estendere la classe MessageListener per poter gestire i messaggi con il metodo onMessage()

Es. intestazione MDB:
	@MessageDriven(activationConfig = {
			@ActivationConfigProperty(propertyName = "destination", propertyValue = "jms/OrderBillingQueue"), //Coda personalizzata
			@ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue") }) //Tipo di coda default
	public class OrderBillingMDB implements MessageListener {
		void onMessage()...
		...
	}

Un bean che chiama un MDB deve definire un connection Factory e una coda a cui agganciarsi:
Es. Oggetti per accesso al MDB
	@Resource(name = "jms/QueueConnectionFactory", mappedName = "ConnectionFactory")
	private QueueConnectionFactory connectionFactory;

	@Resource(name = "jms/OrderBillingQueue", mappedName = "jms/OrderBillingQueue")
	private Queue billingQueue;

Es. Modalità accesso MDBs
	Connection connection = connectionFactory.createConnection();
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	MessageProducer producer = session.createProducer(billingQueue);
	ObjectMessage message = session.createObjectMessage();
	message.setObject(....es. new Object());
	producer.send(message);
	producer.close();
	session.close();
	connection.close();

PERSISTENZA:
Es. istanziazione di un Entity Manager
	@PersistenceContext(unitName = "actionBazaar") //Inietta l'istanza dell'EntityManager
	private EntityManager em;
Es. Crud di un oggetto @Entity
		em.persist(<Object @Entity>);// inserisce l'id nell'oggetto
		em.update(<Object @Entity>);
		em.delete(<Object @Entity>);
Es. generazione di una classe entity
	@Entity //Trasformazione de POJO in entity
	@Table(name="BIDS") //Riferimento alla tabella
	public class Bid implements Serializable { //La classe deve essere serializzabile
		private Long bidID;
		private Long itemID;
		private Long bidderID;
		private Double bidAmount;
		private Date bidDate;
		
		@Id //Costante che definisce l'id della tabella, la chiave primaria
		@GeneratedValue(strategy=GenerationType.AUTO) //tipo di generazione dell'id, qusta modalità indica che ad ogni salvataggio di una nuova istanza la chiave viene generata automaticamente
		@Column(name="BID_ID") //colonna di riferimento
		public Long getBidID() {
			return bidID;
		}
		public void setBidID(Long bidID) {
			this.bidID = bidID;
		}
		
		@Column(name="ITEM_ID") //Colonna di riferimento
		public Long getItemID() {
			return itemID;
		}
		public void setItemID(Long itemID) {
			this.itemID = itemID;
		}
		....
	}


---------------- CAPITOLO 3 ----------------
Un session bean deve:
- avere almento un business interface(@Local o @Remote)
- essere una classe concreta(no abstract method) e non classe final poichè il container deve porterla manipolare
- costruttore senza argomenti(utile al container poichè il client non istanzia direttamente la classe ma usa DI)
- può essere una sotto classe di un altro session bean(? od i una clase POJO)
- i metodi non devono iniziare con 'ejb' poichè interferiscono con il funzionamento dell'infrastruttura
- non si possono definire metodi final o static
- sia gli argomenti che i valori di ritorno devono implementare l'interfaccia Serializable

Sui session bean si possono applicare le annotazioni come interceptor @PostCreate, @PreDestroy, @PostActivate, e @PrePassivate(disattivazione temporanea di un bean non utilizzato, solo per gli stateful session bean)

@Stateless(name='') // attributo utilizzato per mappare il bean nel JNDI, se omesso viene inserito il nome della classe

Un session bean può essere invocato in tre modi: localmente nella JVM (@Local), in maniera remota attraverso RMI(@Remote) e in maniera remota come web service(@WebService).

E' possibile inserire tutte e tre le interfacce per un session bean senza scriverle direttamente uytilizzando il seguente codice:
Es.:
	@Remote(ExampleInterface.class)
	@Stateless
	public class ExampleBean{
	...
	}
	
Negli stateful session bean tutte le vatiabili per soddisfare i requisiti della passivizzazione dell'entity devono essere serializzabili
Al contrario degli stateless non possono essere istanziati e messi in un pool a priori
Esiste l'anotazione @Remove per rimuovere tutti gli oggetti istanziatiche altrimenti rimarrebbero in memoria.
La passivasione salva il bean sul disco e non in memoria, dopo un certo periodo di inutilizzo lo rimuove del tutto.

Continua da pagina 107

 

























