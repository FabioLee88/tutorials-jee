MANNING 2007 - EJB IN ACTION

---------------- CAPITOLO 1 ----------------
Tre tipi di EJB COmponents: session bean, message driven bean, entities. I primi 2 per la logica di business e il terzo per la persistenza.
Il framework EJB contiene una serie di servizi gia implementati che permettono allo sviluppatore di conentrarsi sullo sviluppo della logica di business.
Questi servixi sono avviabili sugli EJB COmponent quando loro sono deployati nel lodo EJB container.
Grazie a Java 5 dove è possibile utilizzare le annotazioni e la dependency injection il container può offirre questi servizi:
- transazioni
- sicurezza
- persistenza
- remotezza
- interceptors
- timers
- state management
- messaggistica

Tramite le annotazioni(metadata) lo sviluppatore dice cosa deve essere fatto e il sistemma aggiunge il codice per farlo.
Una annotazione trasforma un semplice POJO in un EJB.

Siccome i programmi hanno più o meno tutti la stessa logica cioè restituire ed elaborare dati salvati ci si affida a dei pattern utilizzando una architettura a livelli.
Ogni livello fornisce informazioni al livello sottostante.
EJB permette di cotruire applicazioni utilizzando 2 diverse architetture a livelli:
- TRADITIONAL FOUR TIER LAYERED ARCHITECTURE
	a) presentation layer(GUI) per l'imput dell'utente
	b) business logic layer è il cuore dell'applicazione e contiene workflow e processi logici
	c) persistence layer è una astrazione di alto livello Object Oriented del dabase layer
	d) database layer consiste nel database relazionale(RDBMS) come Oracle, DB2, Sql Server...
- DOMAIN DRIVEN DESIGN(DDD)
	Concentrarsi sul dominio e rendere gli oggetti entity capaci di avere comportamenti e di impiegare le caratteristiche dell'OO come l'ereditarietà e il poliformismo.

EJB Component è definito 'bean'
Il persistence provider agisce, come il container per i session e message driven bean, ma per le entity.
Il persistence provider è inserito all'interno del container e si astrae dietro le Java Persistence API (JPA)(FIGURA PAG 16)


SESSION BEAN
Viene invocvato da un client per l'esecuzione di specifiche operazioni di business.
Il nome session implica che un'istanza del bean è avviabile per la durata di una unità di lavoro e non sopravvive e crash o spegnimento del server.
Due tipi:
- Stateful:
	salva automaticamente lo stato del bean tra le invocazioni dello stesso client(Es. il carrello di Amazon)
- Stateless:
	Non mantiene nessuno stato tra una invocazione e l'altra dal aprte di un client(Es. carica carta di credito o controllo storico carta=

Un session bean può essere incovato Localmente o remotamente tramite Java RMI.
Uno stateless session bean può essere esposto come WEB SERVICE


MESSAGE-DRIVEN BEAN
Processa la logica di business.
I clients non invocano il MDB direttamente, ma il MDB viene triggerato dai messaggi inviati al server, che ha abilitato la messaggistica asincrona tra i componenti del sistema.


ENTITIES AND JPA
La persistenza è l'abilità di avere i dati contenuti in oggetti java automaticamente salvati su database relazionali(ORM - object relational mapping/ Es. Hibernate)
In EJB 3 la persistenza è gestita dalle JPA che a sua volta è semplificata tramite gli ORM.
I JPA definiscono uno standard per:
- creazione di mertadata per la configurazione ORM per mappare le entities alle tabelle relazionali
- l'entity manager api - un api standard per eseguire operazioni di persistenza CRUD sulle entity(create, read, update and delete)/
- il Java Persistence Query Language(JPQL), per cercare e trovare dati applicativi stored(salvati sul db)

Si possono aggiungere diversi prodotti ORM sulle JPA come Jboss Hibernate, Oracle TopLink o BEA Kodo utilizzandoli come persistence provider della propria applicazione.

ENTITIES
Sono la rappresentazione OO delle entità presenti sul database e includono capacita ri relazione, ereditarietà e plomorfismo
Contengono metadata per mappare i campi del database con i campi dell'oggetto

ENTITY MANAGER
L'interfaccia JPA EntityManager gestisce le entities in termini di provvedere fisicamente ai servizi di persistenza.
Esso conosce come salvare i dati delle entity nel database, upload e delete e select.
JPA ha la capacità di gestire il cliclo di vita, le perdormance, il caching e il transaction management.
	
JPQL
specifica SQL-LIKE linguaggio delle query

1.3 Pag 19
FIGURA 1.7 Raggruppamento Java EE Container[ web Container, Ejb contaienr, persistence provider]

Glassfish, Jboss hanno JavaEEContainer
Tomcat ha solo {web contaqiner e persistence provider(hibernate)}


SERVIZI GESTITI DALL'EJB CONTAINER E DAL PERSISTENCE PROVIDER
(- Service, = Applies To, >Means)

- Integration
= Session bean and MDBs
> aiuta ad incollare insieme i componenti tramite semplici configurazioni invece di codice.
	Utili sono la dependency injection DI e le lookup

- Pooling
= Stateless session beans, MDBs
> per ogni EJB component l'EJB platform crea un pool di istanze dei suddetti componenti che vengono condivisi tra i clients.
	Quando un client smette di usare una di queste istanze, ques'tultima torna nel pool per essere riutilizzata

- Thread-safety
= Session Beans e MDBs
> Ejb rende tutti i componenti thread safe e performanti in modo invisibile. 
	In questo modo lo sviluppatore può scrivere componenti server come una applicazione single-thread desktop senza preoccuparsi di questa complessità.
	
- State Management
= Stateful session beans
> Il container gestisce in maniera trasparente lo stato delle singole istanze di queste componenti

- Messaging
= MDBs
> permette di scrivere messaggi senza avere idea della logica di comunicazione di tali messaggi.

- Transactions
= Session Beans and MDB
> Configurabile tramite configurazione, no codice. Si può definire un metodo transazionale, se finisce correttamente committa altrimenti fa rollback.

- Security
= Session Beans
> Ejb supporta l'integrazione con le API di Java Authentication and Authorization Service (JAAS). Configurazione no codice.

- Interceprots
= Session beans e MDBs
> permette di separare il logging, l'auditing in maniera configurabile.

- Remote access
= Session beans
> è possibile rendere remoti i componenti senza scrivere codice aggiuntivo ma come se fosse codice locale tramite DI

- Web service
= Stateless session bean
> Ejb 3 può girare di componenti di business in dei web services in maniera trasparente e con piccole modifiche al codice

- persistence
= entities
> é il punto di maggior successo di EJB 3, fornisce servizi basati su standard ed è conigurabile al 100 %

- caching and performance
= entities
> JPA fornisce in maniera trasparente un numero di servizi orinentati al caching dei dati, all'ottimizzazione delle performance e dell'applicazione.

DTO: Data transfer Object creati per la comunicazione dei session ben con il livello di prsentazione poichè non si deve collegare un oggetto entity ad una interfaccia poichè riverserebbe direttamente le modifiche sul db.


---------------- CAPITOLO 2 ----------------
Possono essere utilizzate le annotazioni oppure i deployment descriptor.
Di solito si utilizzano entrambi ma i deployment per specificare la configurazione di un ambiente in particolare e le annotazioni per tutto il resto.
Le annorazioni sono in javax.annotation.*; specificate da Java 5.

Application Client Container(ACC)
è un mini Java EE container che può essere lanciato da linea di comando.
Si può pensare ad una JVM con qualcosa di Java EE iniettato.
Riconosce molte annotazioni come @EJB utile ad iniettare delle classi presenti sul server e quindi remote tramite la DI.
la comunicazione avviene tramite RMI e il container provvede all'autenticazione, autorizzazione, ecc.
Tecnologia utile per i test di unità(JUnit)
Ogni classe con un main gira all'interno dell'ACC in un application client inpacchettato in un file JAR che deve contenere la MainClass anche nel manifest.
Opzionalmente il JAR deve contenere un deployment descriptor(application-client.xml) e jndi.properties che contiene le configurazione dell'ambiene a cui connettersi per un Ejb container remoto.
Esempio di lancio su Glassfish : appclient -client chapter2-client.jar

MESSAGE DRIVEN BEAN(MDB)
@MessageDriven annotazione da mettere sulla classe MDB che contiene la sua configurazione:
	activationConfig: parametro configurazione che contiene le @ActivationConfigProperty
	@ActivationConfigProperty: annotazione che contiene propertyName e properyValue che sono i nome e il path della queue di messaggi salvata
Ogni classe MDB deve estendere la classe MessageListener per poter gestire i messaggi con il metodo onMessage()

Es. intestazione MDB:
	@MessageDriven(activationConfig = {
			@ActivationConfigProperty(propertyName = "destination", propertyValue = "jms/OrderBillingQueue"), //Coda personalizzata
			@ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue") }) //Tipo di coda default, può essere anche Topic
	public class OrderBillingMDB implements MessageListener {
		void onMessage(Message message){
			ObjectMessage objectMessage = (ObjectMessage) message;
			ExampleObject e = (ExampleObject) objectMessage
			...
		}
	}

Un bean che chiama un MDB deve definire un connection Factory e una coda a cui agganciarsi:
Es. Oggetti per accesso al MDB
	@Resource(name = "jms/QueueConnectionFactory", mappedName = "ConnectionFactory")
	private QueueConnectionFactory connectionFactory;

	@Resource(name = "jms/OrderBillingQueue", mappedName = "jms/OrderBillingQueue")
	private Queue billingQueue;

Es. Modalità accesso MDBs
	Connection connection = connectionFactory.createConnection();
	Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	MessageProducer producer = session.createProducer(billingQueue);
	ObjectMessage message = session.createObjectMessage();
	message.setObject(....es. new Object());
	producer.send(message);
	producer.close();
	session.close();
	connection.close();

PERSISTENZA:
Es. istanziazione di un Entity Manager
	@PersistenceContext(unitName = "actionBazaar") //Inietta l'istanza dell'EntityManager
	private EntityManager em;
Es. Crud di un oggetto @Entity
		em.persist(<Object @Entity>);// inserisce l'id nell'oggetto
		em.update(<Object @Entity>);
		em.delete(<Object @Entity>);
Es. generazione di una classe entity
	@Entity //Trasformazione de POJO in entity
	@Table(name="BIDS") //Riferimento alla tabella
	public class Bid implements Serializable { //La classe deve essere serializzabile
		private Long bidID;
		private Long itemID;
		private Long bidderID;
		private Double bidAmount;
		private Date bidDate;
		
		@Id //Costante che definisce l'id della tabella, la chiave primaria
		@GeneratedValue(strategy=GenerationType.AUTO) //tipo di generazione dell'id, qusta modalità indica che ad ogni salvataggio di una nuova istanza la chiave viene generata automaticamente
		@Column(name="BID_ID") //colonna di riferimento
		public Long getBidID() {
			return bidID;
		}
		public void setBidID(Long bidID) {
			this.bidID = bidID;
		}
		
		@Column(name="ITEM_ID") //Colonna di riferimento
		public Long getItemID() {
			return itemID;
		}
		public void setItemID(Long itemID) {
			this.itemID = itemID;
		}
		....
	}


---------------- CAPITOLO 3 ----------------
Un session bean deve:
- avere almento un business interface(@Local o @Remote)
- essere una classe concreta(no abstract method) e non classe final poichè il container deve porterla manipolare
- costruttore senza argomenti(utile al container poichè il client non istanzia direttamente la classe ma usa DI)
- può essere una sotto classe di un altro session bean(? od i una clase POJO)
- i metodi non devono iniziare con 'ejb' poichè interferiscono con il funzionamento dell'infrastruttura
- non si possono definire metodi final o static
- sia gli argomenti che i valori di ritorno devono implementare l'interfaccia Serializable

Sui session bean si possono applicare le annotazioni come interceptor @PostCreate, @PreDestroy, @PostActivate, e @PrePassivate(disattivazione temporanea di un bean non utilizzato, solo per gli stateful session bean)

@Stateless(name='') // attributo utilizzato per mappare il bean nel JNDI, se omesso viene inserito il nome della classe

Un session bean può essere invocato in tre modi: localmente nella JVM (@Local), in maniera remota attraverso RMI(@Remote) e in maniera remota come web service(@WebService).

E' possibile inserire tutte e tre le interfacce per un session bean senza scriverle direttamente uytilizzando il seguente codice:
Es.:
	@Remote(ExampleInterface.class)
	@Stateless
	public class ExampleBean{
	...
	}
	
Negli stateful session bean tutte le vatiabili per soddisfare i requisiti della passivizzazione dell'entity devono essere serializzabili
Al contrario degli stateless non possono essere istanziati e messi in un pool a priori
Esiste l'anotazione @Remove per rimuovere tutti gli oggetti istanziatiche altrimenti rimarrebbero in memoria.
La passivasione salva il bean sul disco e non in memoria, dopo un certo periodo di inutilizzo lo rimuove del tutto.

I stateful session bean possono creare criticità nel sistema, come spreco di memoria a causa di oggetti non eliminati e quindi un calo delle prestazioni.
Alternative ai stateful session bean(di difficile manutenzione i primi 2):
- stateless bean + persistence: per ogni richiesta i dati vengono salvati direttamente sul db.
- aggiungere meccanismi lato client che mantengano lo stato
-* mantenere la sessione in un web container nel caso di una web application. Sebbene l'http è un protocollo stateless le Java servlet Api permettono di mantenere lo stato tramite l'HttpSession.

Best Practice
- scegliere bene se usare stateful o oggetti httpsession e solo se neccessario
- usare interfacce remote solo se necessario
- non iniettare stateful session bean in stateless session bean o in servlet
- separare i concetti incrociati come logging e auditing utilizzando gli interceptor
- scegliere gli oggetti più piccoli o primitivi da salvare come variabili dei stateful
- non dimenticare di creare @Remove per gli stateful
- gestire la passivazione e la configurazione dei timeout


---------------- CAPITOLO 4 ----------------
Una classe MDB deve:
- implementare direttamente o indirettamente(lookup o Di) l'interfaccia messageListener
- deve esdsere una classe concreta e non final o abstract
- non può essere sottoclasse di un altro MDB
- deve essere public
- deve avere un costruttore senza argomenti(se nn c'è viene creato automaticamente)
- esiste il preDestroy

Message selector: utile a filtrare i messaggi, sono criteri applicati all'header o alle proprietà del messaggio.
Es. Creazione del consumer
	MessageConsumer consumer = session.createCostumer(destination, "Fragile IS TRUE");
Es2. Definizione del MDB 
	@ActivationConfigProperty(
		propertyName="messageSelector",
		propertyValue="Fragile IS TRUE")

L'MDB crea un pool di istanze che al momento debito ne tira fuori una per gestire un messaggio e poi appena finito la riporta nel pool.ù

Un MDB può mandare a sua volta messaggi tramite Di in un altra MDB utilizzata ad esempio per tracciare gli errori.
L'apertura e la chiusura della connesione con la coda può essere gestita anche da interceptor @postConstruct e @PreDestroy come per le connesioni al DB.

---------------- CAPITOLO 5 ----------------
Per ogni istanza di un bean, il container in automatico genera un procy chiamato EJB Object. Esso ha accesso a tutte le funzionalità del container(jndi, registry, security,...).
Tramite gli EJB si può accedere al EJBContext come il SessionContext e il MessageDrivenContext utilizzando l'annotazione @Resource, il context è utile per avere informazioni a runtime e servizi
@Resource di solito è usato quando deve essere esplicitato il nome(JDBC, Context, MDB...)
(differenze di utilizzo di @resource sul metodo, variabile o classe)
Tramite @Resource è possibile dare dei parametri a seconda della configurazione dell'ambiente
Es. 
	@Resource(name="valueExample")
	private boolena valueExample
Es.
	<env-entry>
		<env-entry-name>censorship</env-entry-name>
		<env-entry-type>java.lang.Boolean</env-entry-type>
		<env-entry-value>true</env-entry-value>
	</env-entry>

Tramite lookup a differenza della DI è che lke dipendenze vengono specificate programatticamente e che quindi il carico di lavoro
per importare le classi utili avviene a deployment time e non a runtime come per la DI

AOP: Aspect Oriented Programming
Interceptor: 
- default interceptor: definito per tutte le classi presenti nel modulo EJB
- class interceptor 
- method interceptor.
Se sono definiti più di un su un unica classe vengono chaiamati nell'ordine elencato precedentemente.
@AroundInvoke: per definire un metodo in una classe interceptor
Es. 
	@AroundInvoke
	public Object giveDiscount(InvocationContext context) throws Exception {
		System.out.println("*** DiscountVerifier Interceptor" + " invoked for " + context.getMethod().getName() + " ***");
		if (context.getMethod().getName().equals("chargePostingFee") && (((String)(context.getContextData().get("MemberStatus"))).equals("Gold"))) {
			Object[] parameters = context.getParameters();
			parameters[2] = new Double ((Double) parameters[2] * 0.99);
			System.out.println ("*** DiscountVerifier Reducing Price by 1 percent ***");
			context.setParameters(parameters);
		}
		return context.proceed();
	}
Per utilizzarlo su una classe o su un metodo: @Interceptors({ActionBazaarResourceLogger.class})
Definizione di uno di default:
	<assembly-descriptor>
		<interceptor-binding>
		<ejb-name>*</ejb-name>
		<interceptor-class>
			actionbazaar.buslogic.ActionBazaarLogger
		</interceptor-class>
		</interceptor-binding>
	</assembly-descriptor>
Esistono funzionalità per rimuovere l'interceptor @ExcludeDefaultInterceptors e @ExcludeClassInterceptors.


@Timer utile per schedulare il lancio di alcuni metodi
ES.
	public class PlaceBidBean implements PlaceBid {
		...
		@Resource TimerService timerService;
		...
		public void addBid(Bid bid) {
			... Code to add the bid ...
			timerService.createTimer(15*60*1000, 15*60*1000, bid);  //creato il timer
			...
		}
		...
		@Timeout     //metodo di timeout
		public void monitorBid(Timer timer) { //Nella  firma c'è la classe timer
			Bid bid = (Bid) timer.getInfo();
			... Code to monitor the bid ...
		}
	}
Si può accedere al timer service anche tramite SessionContext
I timer Ejb sopravvivono al restart dell'EJB Container ma non sono buone per applicazioni realtime


---------------- CAPITOLO 6 ----------------
Context managed transaction: CMT
Transazionale: ACID(Atomicity, Consistency, isolation, Durability)
Lock di basso livello sul database per i dati modificati dalla transazione, nessun'altro li può modificare fino a quando non termina la transazione.
Es.
	@Stateless
	@TransactionManagement(TransactionManagementType.CONTAINER) //Utilizzato CMT Container-menaged transaction
	public class OrderManagerBean {
		@Resource    															//Inject del contesto utile per il rollback
		private SessionContext context;
		...
		@TransactionAttribute(TransactionAttributeType.REQUIRED)  				//Definito un attributo di transaction per metodo
		public void placeSnagItOrder(Item item, Customer customer){				//attributi: REQUIRED, REQUIRES_NEW, SUPPORTS, MANDATORY, NOT_SUPPORTED, NEVER
			try {
				if (!bidsExisting(item)){
					validateCredit(customer);
					chargeCustomer(customer, item);
					removeItemFromBidding(item);
				}
			} catch (CreditValidationException cve) { 							//Roolback in caso di eccezione
				context.setRollbackOnly();										// il contesto viene marcato "da rollbackare" e fatto successivamente(solo per REQUIRED, REQUIRES_NEW, MANDATORY altrimenti va in eccezione)
			} catch (CreditProcessingException cpe){
				context.setRollbackOnly();
			} catch (DatabaseException de) {
			}
		}
	}
MDB supporta solo: REQUIRED e NOT_SUPPORTED
@ApplicationException: utilizzato per gestire i rollback sulle eccezioni
Es. Rimozione del try catch ed eccezioni personalizzate
	public void placeSnagItOrder(Item item, Customer customer)throws CreditValidationException,	CreditProcessingException, DatabaseException {
		if (!bidsExisting(item)){
			validateCredit(customer);
			chargeCustomer(customer, item);
			removeItemFromBidding(item);
		}
	}
	...
	@ApplicationException(rollback=true)
	public class CreditValidationException extends Exception {
	...
	@ApplicationException(rollback=true)
	public class CreditProcessingException extends Exception {
	...
	@ApplicationException(rollback=false)
	public class DatabaseException extends	RuntimeException {
	...
 
Bean managed transaction: BMT (puo dettagliare le scelte sulle transazioni)
Es.
	@Stateless
	@TransactionManagement(TransactionManagementType.BEAN) //Use BMT
	public class OrderManagerBean {
		@Resource
		private UserTransaction userTransaction;  //Inject User transaction
		
		public void placeSnagItOrder(Item item, Customer customer){
			try {
				userTransaction.begin();   //Start transaction
				if (!bidsExisting(item)){
					validateCredit(customer);
					chargeCustomer(customer, item);
					removeItemFromBidding(item);
				}
				userTransaction.commit();   //Commit transaction
				
			} catch (CreditValidationException cve) { //Rolls back sulle eccezioni
				userTransaction.rollback();
			} catch (CreditProcessingException cpe){
				userTransaction.rollback();
			} catch (DatabaseException de) {
				userTransaction.rollback();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	
L'oggetto user transaction oltre tramite @resource può essere invocato mediante 2 metodi:
- JNDI Lookup
	Context context = new InitialContext();
	UserTransaction userTransaction = UserTransaction) context.lookup("java:comp/UserTransaction");
	userTransaction.begin();
	// Perform transacted tasks.
	userTransaction.commit();
- EjbContext:
	@Resource
	private SessionContext context;
	...
	UserTransaction userTransaction = context.getUserTransaction();
	userTransaction.begin();
	// Perform transacted tasks.
	userTransaction.commit();
 
EJB 3 e Java EE SECURITY
La sicurezza di Java EE è basata sulla Java Authentiucation and Authorization Service (JAAS) API.
JAAS separa l'autenticazione dal sistema tramite un'API pluggabile e quindi sostituibile senza cambiare il codice.
PRINCIPAL: utente validato
Di solito il Web Tier effettua l'autenticazione e passa il Pricipal all'EJb tier, quando non può più essere passata la validazione viene effettuata nuovamente
L'autenticazione è configurabile nel web.xml tramite i tag login-config e security-costraint
Es.
	<login-config>
		<auth-method>BASIC</auth-method>			//Attivazione del controllo da parte del container
		<realm-name>ActionBazaarRealm</realm-name>  //Astrazione di un JAAS container
	</login-config>
	...
	<security-constraint>
		<web-resource-collection>
			<web-resource-name>
				ActionBazaar Administrative Component
			</web-resource-name>
			<url-pattern>/admin/*</url-pattern> //path da mettere in sicurezza
		</web-resource-collection>
		<auth-constraint>
			<role-name>CSR</role-name> // gruppo di utenti che può accedere all'area protetta
		</auth-constraint>
	</security-constraint>


Auth method: BASIC usa l'header del protocollo http, FORM come BASIC ma con un form, CLIENT-CERT usa connesione SSL con i certificati salvati nel browser 

DECLARATIVE SECURITY
Es. 
	@DeclareRoles("BIDDER", "CSR", "ADMIN") //Dichiara i tuoli per ilo bean
	@Stateless
	public class BidManagerBean implements BidManager {
		
		@RolesAllowed("CSR, ADMIN")				//dichiara ruoli che accedono al metodo
		public void cancelBid(Bid bid, Item item) {...}
		
		@PermitAll								// tutti possono accedere al metodo (l'opposto @DenyAll)
		public List<Bid> getBids(Item item) {...}
	}

Si potrebbe definire i Roles direttamente per tutto l'ejb module tramite deployment descriptor

@RunAs utile a lanciare un metodo con un ruolo ben definito
Es.
	@RunAS("ADMIN")
	@RolesAllowed("CSR")
	public void cancelBid(Bid bid, Item item) {...}
	
PROGRAMMATIC SECURITY
gestire manualmente la sicurezza.
Es.
	@Stateless
	public class BidManagerBean implements BidManager {
	@Resource SessionContext context;											//Inject Context
		...
		public void cancelBid(Bid bid, Item item) {
			if (!context.isCallerInRole("CSR")) {								//Verifica Ruolo, (getCallerPrincipal() restituisce il Principal loggato)
				throw new SecurityException("No permissions to cancel bid"); 	//Eccezione sicurezza
			}
			...
		}
		...
	}

Di solito si utilizza la sicurezza programmaticamente tramite l'aiuto degli interceptor che eseguono il lavoro in maniera "nascosta"

---------------- PARTE 3 - JPA ----------------
---------------- CAPITOLO 7 ----------------

@Entity, @Embedded, @Id, @OneToMany, @OneToOne, @ManyToMany, @ManyToOne, @Table, @Column, @JoinColumn

@Transient: non salvato sul DB

Annotazioni utili a definire l'identificativo:
- @Id: chiave semplice
- @IdClass: chiave composta
	public class CategoryPK implements Serializable {
		String name;
		Date createDate;
		public CategoryPK() {}
		public boolean equals(Object other) {		// metodo di confronto
			if (other instanceof CategoryPK) {
				final CategoryPK otherCategoryPK = (CategoryPK)other;
				return (otherCategory.name.equals(name) &&
				otherCategoryPK.createDate.equals(createDate));
			}
			return false;
		}
		public int hashCode() {
			return super.hashCode();
		}
	}
	@Entity
	@IdClass(CategoryPK.class)    //Classe che indentifica la chiave primaria
	public class Category {
		public Category() {}
		@Id
		protected String name;
		@Id
		protected Date createDate;
		...
	}
- @EmbeddedId: chiave composta ma la classe che identifica la chiave è incorporata nell'entity
Es.
	@Embeddable
	public class CategoryPK {
		String name;
		Date createDate;
		public CategoryPK() {}
		public boolean equals(Object other) {
			if (other instanceof CategoryPK) {
				final CategoryPK otherCategoryPK = (CategoryPK)other;
				return (otherCategory.name.equals(name) &&
				otherCategoryPK.createDate.equals(createDate));
			}
			return false;
		}
		public int hashCode() {
			return super.hashCode();
		}
	}
	@Entity
	public class Category {
		public Category() {}
		@EmbeddedId
		protected CategoryPK categoryPK;
		...
	}

Es.2
	@Embeddable
	public class Address {
		protected String streetLine1;
		protected String streetLine2;
		protected String city;
		protected String state;
		protected String zipCode;
		protected String country;
		...
	}
	@Entity
	public class User {
		@Id
		protected Long id;
		protected String username;
		protected String firstName;
		protected String lastName;
		@Embedded
		protected Address address;
		protected String email;
		protected String phone;
		...
	}


Es. @OneToOne bidirezionale:
	@Entity
	public class User {
		@Id
		protected String userId;
		protected String email;
		@OneToOne
		protected BillingInfo billingInfo;
	}
	@Entity
	public class BillingInfo {
		@Id
		protected Long billingId;
		protected String creditCardType;
		..
		protected String routingNumber;
		@OneToOne(mappedBy="billingInfo", optional="false");
		protected User user;
	}

Es. OneToMany bidirezionale
	@Entity
	public class Item {
		@Id
		protected Long itemId;
		protected String title;
		protected String description;
		protected Date postdate;
		...
		@OneToMany(mappedBy="item")
		protected Set<Bid> bids;
		...
	}
	@Entity
	public class Bid {
		@Id
		protected Long bidId;
		protected Double amount;
		protected Date timestamp;
		...
		@ManyToOne
		protected Item item;
		...
	}

Es. ManyToMany
	@Entity
	public class Category {
		@Id
		protected Long categoryId;
		protected String name;
		...
		@ManyToMany
		protected Set<Item> items;
		...
	}
	@Entity
	public class Item {
		@Id
		protected Long itemId;
		protected String title;
		...
		@ManyToMany(mappedBy="items")
		protected Set<Category> categories;
		...
	}

---------------- CAPITOLO 8 ----------------
@Enumerated: utile a definire tipi enumerativi
@Lob: per denotare campi BloB o Clob(salvataggio immagini sul db)
Es.
	@Lob
	@Basic(fetch=FetchType.LAZY)
	protected byte[] picture;

@temporal: utilizzato per definire le date(date, time, timestamp)
Una Entity può essere mappata a più tabelle utilizzando l'annotazione @SecondaryTable
Es.
	@Entity
	@Table(name="USERS")
	@SecondaryTable(name="USER_PICTURES", pkJoinColumns=@PrimaryKeyJoinColumn(name="USER_ID"))
	public class User implements Serializable {
	..
Es. One to one con @PrimaryKeyJoinColumn
	@Entity
	@Table(name="USERS")
	public class User {
		@Id
		@Column(name="USER_ID")
		protected Long userId;
		...
		@OneToOne
		@PrimaryKeyJoinColumn(name="USER_ID", referencedColumnName="BILLING_USER_ID")
		protected BillingInfo billingInfo;
	}
	
	@Entity
	@Table(name="BILLING_INFO")
	public class BillingInfo {
		@Id
		@Column(name="BILLING_USER_ID")
		protected Long userId;
		...
	}
Es. One to many bidirectional
	@Entity
	@Table(name="ITEMS")
	public class Item {
		@Id
		@Column(name="ITEM_ID")
		protected Long itemId;
		...
		@OneToMany(mappedBy="item")
		protected Set<Bid> bids;
		...
	}
	@Entity
	@Table(name="BIDS")
	public class Bid {
		@Id
		@Column(name="BID_ID")
		protected Long bidId;
		...
		@ManyToOne
		@JoinColumn(name="BID_ITEM_ID",
		referencedColumnName="ITEM_ID")
		protected Item item;
		...
	}

Es. Many to many
@Entity
@Table(name="CATEGORIES")
public class Category implements Serializable {
	@Id
	@Column(name="CATEGORY_ID")
	protected Long categoryId;
	@ManyToMany
	@JoinTable(name="CATEGORIES_ITEMS", 
		joinColumns= @JoinColumn(name="CI_CATEGORY_ID", referencedColumnName="CATEGORY_ID"),
		inverseJoinColumns= @JoinColumn(name="CI_ITEM_ID", referencedColumnName="ITEM_ID"))
	protected Set<Item> items;
	...
}
@Entity
@Table(name="ITEMS")
public class Item implements Serializable {
	@Id
	@Column(name="ITEM_ID")
	protected Long itemId;
	...
	@ManyToMany(mappedBy="items")
	protected Set<Category> categories;
	...
}
Es.Single table: Creare una colonna che funga da discriminante tra due entità sulla stessa tabella(utilizzo dell'ereditarietà)
	@Entity
	@Table(name="USERS")
	@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
	@DiscriminatorColumn(name="USER_TYPE", discriminatorType=DiscriminatorType.STRING, length=1)
	public abstract class User ...
	
	@Entity
	@DiscriminatorValue(value="S")
	public class Seller extends User ...
	
	@Entity
	@DiscriminatorValue(value="B")
	public class Bidder extends User

Es. La Join Tables Strategy: la tabella comune contiene solo colonne comuni, le altre due tabelle sono in join per completare le 2 entità
	@Entity
	@Table(name="USERS")
	@Inheritance(strategy=InheritanceType.JOINED)
	@DiscriminatorColumn(name="USER_TYPE", discriminatorType=STRING, length=1)
	public abstract class User ...
	
	@Entity
	@Table(name="SELLERS")
	@DiscriminatorValue(value="S")
	@PrimaryKeyJoinColumn(name="USER_ID")
	public class Seller extends User ...
	
	@Entity
	@Table(name="BIDDERS")
	@DiscriminatorValue(value="B")
	@PrimaryKeyJoinColumn(name="USER_ID")
	public class Seller extends User ...
	
Es. table-per-class - tabelle completamente dedicate ad una classe, anche se hanno colonne con stesso nome
	@Entity
	@Table(name="USERS")
	@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
	public class User {
	...
	@Entity
	@Table(name="SELLERS")
	public class Seller extends User {
	...
	@Entity
	@Table(name="BIDDERS")
	public class Bidder extends User {
	
---------------- CAPITOLO 9 ----------------	
L'Entitymanager si occupa del ciclo di vita delle entity e di aggiornare le entity con lo stato del Db fino a quando sono attached
Un'entity diventa attached quando vengono utilizzati i metodi come persist, merge, refresh o tramite un find
Il detach avviene quando la entity esce dallo scope dell'entity manager, ad es viene passata tra i vari livelli, come al web tier, una volta che la entity ritorna è possibile utilizzare il merge per aggiornare la entity attached.
Im metodo clear dell'entity manager detacha tutte le entity, inoltre le entity si detachano tramite clonazione e serializzazione.
Il metodo remove oltre a rimouvere l'entity dal db esegue il detach.
	
Un persistence context è una collezione di entità gestite da entitymanager durante un dato persistence scope(resta in vita per la durate delle entity attached).
Transaction-scoped entity manager: le entità vengono detachate al termine di ogni transazione(ciclo di vita del persistence context, scope e EM in ogni transazione) 
Extended Entity Manager: sopravvive a più transazioni( utilizzato solo per stateful session bean)
E. 
	@PersistenceContext(name="", //nome JNDI del persistence context	
						unitName = "actionBazaar", //nome della persistence unit, raggrupa entity(GENERAL, ADMIN) 
						type = PersistenceContextType.EXTENDED, //default TRANSACTION
						properties= ""
						)
	private EntityManager entityManager;
	...
Per configurare il contesto di persistenza si deve utilizzare il file persistence.xml (deployment descriptor)	
L'EntityManager non è thread safe ma L'entityManagerFactory si, quindi si potrebbe gestire manualemte il thread safe in un sistema EE tramite application-managed Entitymanager
Es.
	@Stateless
	public class ItemManagerBean implements ItemManager {
		@PersistenceUnit
		private EntityManagerFactory entityManagerFactory;
		private EntityManager entityManager;
		public ItemManagerBean() {}
		
		@PostConstruct
		public void initialize() {
			entityManager = entityManagerFactory.createEntityManager();
		}
		...
		public Item updateItem(Item item) {
			entityManager.joinTransaction();
			entityManager.merge(item);
			return item;
		}
		...
		@PreDestroy
		public void cleanup() {
			if (entityManager.isOpen()) {
				entityManager.close();
			}
		}
		...
	}
	
In Java SE JTA non è utilizzabile e quindi bisogna implementarla manualmente
Es.
	EntityManagerFactory entityManagerFactory =
	Persistence.createEntityManagerFactory("actionBazaar");
	EntityManager entityManager = entityManagerFactory.createEntityManager();
	try
	{
		EntityTransaction entityTransaction = entityManager.getTransaction();
		entityTransaction.begin();
		entityManager.persist(item);
		entityTransaction.commit();
	}
	finally
	{
		entityManager.close();
		entityManagerFactory.close();
	}
	
Utilizzo di JPA	in un web container e il ThreadLocal pattern
Su, ad esempio tomcat e jetty alcuni provider di persistenza come hibernate raccomandano l'utilizzo del pattern threadLocal dove ogni singola istanza di un entityManager viene inserita all'interna di un singolo thread
Es.
	private static EntityManagerFactory emf;
	public static final ThreadLocal<EntityManager> _threadLocal = new ThreadLocal<EntityManager>();
	public static EntityManagerFactory getEntityManagerFactory() {
		if (emf == null) {
			emf = Persistence.createEntityManagerFactory("actionBazaar");
		}
		return emf;
	}
	public static EntityManager getEntityManager() {
		EntityManager entityManager = _threadLocal.get();
		if (entityManager == null) {
			entityManager = emf.createEntityManager();
			_threadLocal.set(entityManager);
		}
		return entityManager;
	}
	
Se una entity ha una relazione one-to-one e si vuole eseguire un persist delle due entità simultaneamente si può fare(id vuoto delle entity)
Es. 
	public User addUser(String username, String email, String creditCardType, String creditCardNumber, Date creditCardExpiration) {
		User user = new User();
		user.setUsername(username);
		user.setEmail(email);
		BillingInfo billing = new BillingInfo();
		billing.setCreditCardType(creditCardType);
		billing.setCreditCardNumber(creditCardNumber);
		billing.setCreditCardExpiration(creditCardExpiration);
		user.setBillingInfo(billing);									//Innestata un'entità nell'altra(2 nuove entità non attached)
		entityManager.persist(user);						//persist(salvataggio di due entità)
		return user;
	}	
	
	...Codice entity
	public class User {
		@OneToOne(cascade=CascadeType.PERSIST)  // Operazione da eseguire a cascata(MERGE,PERSIST, REFRESH, REMOVE e ALL)
		public void setBillingInfo(BillingInfo billing) {
		...
	
Modi per fare il fetch dei dati dal Database da parte dell'entity manager:
- Eager(avido): scarica tutti i dati al momento della richiesta(molto + oneroso come per le immagini)	
- LAZY(pigro): si crea un riferimento alkll'elemento del db ma non vengono caricate le singole colonne, i dati vengono recuperati al momento della prima getX() chiamata
Si usa l'annotazione sulla colonna @Basic(fetch=FetchType.LAZY)
Se un'entità è corredata da una relazione come ad esempio one-to-many al caricamento dal db di quella entità verranno recuperate anche le altre associate.
Di Default queste entità correlate vengono caricate in maniera lazy per one-to-many e per many-to-many, Eager per one-to-one e many-to-one, ma è possibile personalizzarle tramite l'attributo fetch
EntityManager.merge(Item xx) serve per aggiornare sul db una entity che è stata detachata.Se non la trova lancia una IllegalStateException
Se nell'entity manager viene settato @ManyToOne(cascade=CascadeType.MERGE)	 oppure ALL allora verranno mergiate anche le inner entity
Lo stesso vale per il delete: @OneToOne(cascade=CascadeType.REMOVE) o ALL
	
FLUSH dell'EntityManager: settato ad AUTO di default.
i persist, merge e remove a volte non vengono fatti istantaneamente, il flush viene posticipato a momenti più opportuni per ottimizzare le risorse.
Si può gestire il flush tramite l'entitymanager.setFlushMode(FlushModetype.COMMIT) (: ogni transazione di commit verso il Db viene flushata)
Avvio del flush manualmente entityManager.flush()
La funzionalità Entitymanager.refresh() forza il ricaricamento dell'entità dal database.
Ci sono degli Entity Listener (come interceptor) per le JPA e sono: @PrePersist, @PostPersist, @PostLoad, @PreUpdate, PostUpsate, @PreRemove, @PostRemove
Es.
	public class ItemMonitor {
		...
		public ItemMonitor() {}
		@PrePersist
		@PreUpdate
		public void monitorItem(Item item) {
			if (item.getInitialBidAmount() > ItemMonitor.MONITORING_THRESHOLD) {
				notificationManager.sendItemPriceEmailAlert(item);
			}
		}
	}
	@Entity
	@EntityListeners(actionbazaar.persistence.ItemMonitor.class)
	public class Item implements Serializable {
	...

Per impostare un listener di default su tutte le entity si usa il deployment descriptor nel file persistence.xml
Es. Logger sulle remove
	LoggerClass:
	public class ActionBazaarAuditor {
	...
	@PrePersist
	@PostPersist
	...
	@PostRemove
	public void logOperation(Object object) {
	Logger.log("Performing Persistence Operation on: " + object.getName());
	
	persistence.xml:
	<persistence-unit name="actionBazaar">
		...
		<default-entity-listeners>
			actionbazaar.persistence.ActionBazaarAuditor.class
		</default-entity-listeners>
		...

Viene eseguito prima il default listener, poi i listener della superclasse e poi quelli della sottoclasse.

Ci sono modi per evitare che vengano lanciati i listener su una determinata entity
Es.
	@Entity
	@ExcludeDefaultListeners  //Esclude il listener di default
	@ExcludeSuperClassListeners  //Esclude i listener delle classi padre
	@EntityListeners(actionbazaar.persistence.SellerMonitor.class) // definisce un entity listener(o più di uno)
	public class Seller extends User {

---------------- CAPITOLO 10 ----------------	
Con le JPA ci sono tre modi per recuperare i dati:
- EntityManager.find
- Query scritte in JPQL
- Query SQL native sul database sottostante

Ci sono due tipi di query: 
- named: Possono essere memorizzate e riutilizzate
- dynamic: query che viene composta dinamicamente in base al tipo di entità, stato, input...
Es.
	@PersistenceContext em; //entityManager
	...
	public List findAllCategories() {
		Query query = em.createQuery("SELECT c FROM Category c"); ... //Query dinamica ( per creare una named query si usa createNamedQuery(String name))
		return query.getResultList(); ............
	}

Per creare una named query si possono utilizzare delle annotazioni oppure definirla come metadata in file XML.
Es. named query con annotazioni
	@Entity
	@NamedQuery(
		name = "findAllCategories",
		query = "SELECT c FROM Category c WHERE c.categoryName LIKE :categoryName ")
	public class Category implements Serializable {
		..
	}
Es. multiple query
	@Entity
	@NamedQueries({
		@NamedQuery(
			name = "findCategoryByName",
			query = "SELECT c FROM Category c WHERE c.categoryName LIKE :categoryName order by c.categoryId"
		),
		@NamedQuery(
			name = "findCategoryByUser",
			query = "SELECT c FROM Category c JOIN c.user u WHERE u.userId = ?1"
		)
	})
	@Table(name = "CATEGORIES")
	public class Category implements Serializable {
	}

Il "name" deve essere unico!

public Query createQuery(String qlString); Creates a dynamic query using a JPQL statement.
public Query createNamedQuery(String name); Creates a query instance based on a named query. This method can be used for both JPQL and native SQL queries.
public Query createNativeQuery( String sqlString); Creates a dynamic query using a native SQL statement with UPDATE or DELETE.
public Query createNativeQuery( String sqlString,Class result-class); Creates a dynamic query using a native SQL statement that retrieves a single entity type.
public Query createNativeQuery( String sqlString,String result-setMapping); Creates a dynamic query using a native SQL statement that retrieves a result set with multiple entity types.

Es. creazione named query
	Query query = em.createNamedQuery("findAllCategories");
	
Es. named query con parametri
	query = em.createNamedQuery("findCategoryByName");
	query.setParameter("categoryName", categoryName);
	query.setMaxResults(10);
	query.setFirstResult(3);
	List categories = query.getResultList();

Se nella named query ci sono dei parametri sono con il punto interrogativo oppure con i due punti
Es. 
	SELECT i FROM Item i WHERE i.initialPrice > ?1 AND i.initialPrice < ?2

	query.setParameter(1, 100.00);
	query.setParameter(2, 200.00);
Es.2
	SELECT i FROM Item i WHERE i.initialPrice = :price

	query.setParameter("price", 100.00);

Recupero di un risultato singolo: Category cat = (Category)query.getSingleResult(); (se ne trova 0 o piu di uno va in eccezione)


//*/*/*/*/*/ Continua da pagina 351: Pagination







		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



 
 