DESIGN PATTERNS

- Creational pattern:
	utile alla creazione di oggetti, incapsulando tutta la logica della creazione
	spesso inizializza direttamente gli oggetti restituiti
- Structural pattern:
	definisce metodologie di composizione della struttura delle classi, ereditarietà e interfacce
	definice modi per strutturare classi e oggetti in modo da ottenere nuove funzionalità
- Behavioral pattern:
	è specifica per la comunicazione tra gli oggetti(definisce il comportamento)
- J2EE Pattern:
	identificati dalla Sun Java Center, sono specifici per il presentation tier(livello di presentazione)
	

CREATIONAL PATTERN

- Factory pattern:
	Di solito prevede la creazione di una classe "factory" utile 
	per la creazione degli oggetti (es. <<Shape>>, ClassRectangle, ClassCircle, ClassSquare , ShapeFactory)
	
- Abstract Factory Pattern:
	Concetto più elevato del Factory pattern che è utile alla creazione direttamente delle classi Factory

- Singleton pattern:
	Creazione di un unico oggetto a partire dalla classe(se nn c'è lo crea se c'è usa quello)
	
- Builder Pattern:
	Costruisce oggetti colplessi partendo da oggetti semplici e procedendo passo dopo passo
	
- Prototype pattern:
	Duplica gli oggetti per migliorare le performance.
	Utilizzando la clonazione degli oggetti e tenendo i nuovi oggetti in cache
	evita di effettuare le operazioni di creazione oppure di recupero dal db degli oggetti che 
	possono essere onerose(+ tempo)

STRUCTURAL PATTERN
	
- Adapter Pattern:
	Si comporta come un ponte fra due interfacce incompatibili. (Adattatore)

- Bridge Pattern:
	Separare la classe astratta dalla sua implementazione

- filter pattern/criteria pattern:
	Interfaccia e diversi comportamenti

- Composite pattern:
	raggruppare oggetti diversi o liste di oggetti in un unico oggetto o in un albero di oggetti
	
- decorator pattern:
	aggiungere funzionalità ad un oggetto senza modificare la struttura dello stesso(Creazione di Wrapper)
	
- Facade pattern:
	aggiunge una interfaccia(classe intermedia/ classe facciata) al sistema per ridurne la complessità, estrapolando tutte le funzionalità utili
	
- FlyWeight pattern:
	utile a ridurre il numero degli oggetti generati dal sistema in modo da migliorare le performance
	riutilizza gli oggetti gia generati
	
- Proxy pattern:
	creazione di una classe che funge da tramite per le funzionalità di un'altra classe in modo da ottimizzarne le funzionalità salvandosi in memoria le cose gia richieste 
	in modo da non effettuarne nuovamente la richiesta

BEHAVIORAL PATTERN:

- Chain of responsability pattern:
		creazione di una catena di oggetti ricevitori per una singola richiesta
		il modello disaccoppia mittente e ricevitore in base al tipo di richiesta
		in questo pattern ogni ricevitore contiene il link al ricevitore successivo, se lui stesso non riesce a gestire la richiesta la gira al ricevitore successivo
		
- Command pattern:
	una richiesta viene wrappata in un oggetto "comando" ed inviata ad in oggetto "invoker" che guarda di che tipo è il comando
	e rigira la richiesta al giusto gestore

- Interpreter pattern:
	utilizzato per interpretare e validare espressioni (es. SQL)
	
- Iterator pattern:
	Classe Iteratore che si muove sulla lista di elementi senza sapere che tipo di implementazione abbia la lista

- Mediator pattern:
	riduce la complessita di comunicazione tra oggetti e classi multiple inserendo una classe che ne fa da mediatore
	
- memento pattern:
	utile a ripristinare una precedente versione dello stato di un oggetto

- observer pattern:
	utilizzato nelle relazioni uno a molti: quando un oggetto viene modificato, la modifica viene notificata a tutti gli altri oggetti
	
- state pattern:
	il comportamento di una classe cambia in base al suo stato
	
- Null object pattern:
	viene creato un oggetto che rappresenta il valore null, utilizzato anche come valore di default

- Strategy pattern:
	consente la modifica del comportamento di una classe o di un algorimo a runtime
	vengono definite le classi comportamento e in base allo stato del sistema vengono passate ad una classe contesto che le esegue 

- Template pattern:
	in questo pattern una classe astratta definisce dei metodi astratti privati e dei metodi final pubblici che richiamano gli astratti, le sue sotto classi personalizzeranno il comportamento dei metodi astratti pur lasciando invariato il comportamento della classe verso l'esterno(public final)
	
- Visitor pattern:
	comporta la creazione di una classe Visitatore che in base all'elemento visitato modifica l'algoritmo di esecuzione
	
- MVC Pattern:
	Model View Controller Pattern

J2EE PATTERN:	
	
- Business Delegate Pattern:
	Utilizzato per disaccoppiare il livello di presentazione da quello di business.
	è essenzialmente usato per ridurre le lookup remote e ridurre le comunicazioni con il livello di business dal livello di presentazione.
	Entità: Client, Business Delegate, LookUp Service, Business Service
	
- Composite Entity Pattern:
	utilizzato nei meccanismi di persistenza degli EJB.
	Un'entità composta è un EJB entity bean che rappresenta un grafo di oggetti.
	Quando questa entità composta viene aggiornata , tutti gli oggetti interni vengono aggiornati automaticamente e gestiti dall'EJB entity bean.
	Entità interessate: Composite Entity, Coarse-Grained Object

- Data Access Object Pattern(DAO):
	usato per separare le api di accesso ai dati di basso livello oppure le operazioni da alti livelli di business service.
	Entità: Data Access Object Interface, Data Access Object Concrete class, Model Object or Value Object
	
- Front Controller Pattern:
	è usato per centralizzare il meccanismo di gestione delle rischieste, cosi da sottoporre tutte le richieste ad un handler unico
	questo handler potrà effettuare l'autenticazione/autorizzazione/logging e tracking delle request 
	e successivamente passare le request all'handler corrispettivo
	Entity: Front Controller, Dispatcher, View
	
- Intercepting Filter Pattern:
	utilizzato quando si vuole qualcosa prima o dopo aver intercettato una request o inviato una response
	Vengono applicati dei Filtri allre richieste che prima di leggere la richiesta possono eseguire l'autenticazione, l'autorizzazione, logging e tracking e successivamente passare la richiesta all'handler.
	Entità: Filter, FilterChain, Target, FilterManager, Clients
	
- Service Locator Pattern:
	è usato per individuare i servizi utilizzando JNDI.
	consideraando il costo elevato di individuazione di JNDI, il pattern utilizza tecniche di caching.
	Il service Locator utilizza JNDI per individuare il servizio, per tutti i prossimi lookuo del medesimo servizio, esso è gia in cache e quindi aumenta le prestazioni.
	Entities: Service, Context/Initial Context, Service Locator, cache, Client
	
- Transfer Object Pattern:
	Utilizzato quando si vuole passare in un colpo solo dati degli attributi multipli dal client al server.
	Oggetto POJO con getter e setter che può essere serializzato per il trasferimento in rete che contiene tutti gli attributi da inviare(Classe contenitore serializzabile).
	Entities: Business Object, Transfer Object, Client.